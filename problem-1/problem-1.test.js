/*
1. 다음은 버블 정렬의 알고리즘입니다. 알고리즘을 보고 다음 값이 주어졌을 때
   어떻게 정렬이 되는지 그림으로 그려보세요.

> 1. 첫 번째 원소부터 시작하여 인접한 두 원소를 비교합니다. 
> 2. 두 원소가 올바른 순서로 되어 있지 않으면 교환합니다. 
> 3. 다음 원소로 이동하고 1-2 단계를 반복합니다. 
> 4. 한 패스가 끝나면 가장 큰 원소(또는 가장 작은 원소)가 배열의 끝으로 이동합니다. 
> 5. 배열의 모든 원소가 올바른 위치에 있을 때까지 전체 배열에 대해 이 과정을 반복합니다.

```
4, 2, 1, 5, 3
```
패스1
[4, 2, 1, 5, 3]  ->  [2, 4, 1, 5, 3]  ->  [2, 1, 4, 5, 3]  ->  [2, 1, 4, 3, 5]

패스2
[2, 1, 4, 3, 5]  ->  [1, 2, 4, 3, 5]  ->  [1, 2, 3, 4, 5]

2. 버블 정렬의 코드를 보고 어떻게 동작하는지 그림을 그려보세요. 마찬가지로 위의 값이 주어졌다고 했을 때 코드를 따라가며 그림을 그려가며 이해해 보세요.

3. 버블 정렬의 코드를 직접 구현해 주세요.

4. (추가 문제) 버블 정렬은 이미 정렬되어 있다면, 더 이상 정렬을 수행하지 않고
   정렬을 일찍 종료할 수 있습니다. 이를 코드에 구현해 주세요.
*/

const exchange = (array, a, b) => {
  [array[b], array[a]] = [array[a], array[b]];
};

const compare = (array, a, b) => array[a] < array[b];

const bubbleSort = (array) => {
  for (let i = 0; i < array.length; i++) {
    let isSwapped = false;
    for (let j = 0; j < array.length - i - 1; j++) {
      if (compare(array, j + 1, j)) {
        exchange(array, j, j + 1);
        isSwapped = true;
      }

      if (!isSwapped) {
        break;
      }
    }
  }
};

test.each([[[5, 4, 3, 2, 1]], [[1, 2, 3, 4, 5]], [[4, 2, 1, 5, 3]]])(
  "주어진 배열을 오름차순으로 정렬한다",
  (array) => {
    bubbleSort(array);

    expect(array).toEqual([1, 2, 3, 4, 5]);
  }
);
